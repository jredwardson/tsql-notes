## Inserting Data
### INSERT VALUES
Insert values directly
```sql
INSERT INTO <table> (<columns>)
VALUES(<values to insert>)
```

Columns that are not specified are assigned NULLs if possible, or a default/identity value if specified in the table definition

`IDENTITY_INSERT ON` option allows you to specify values for autogenerated IDENTITY columns

### INSERT SELECT
Insert values based on a query
```sql
INSERT INTO <table> (<columns>)
SELECT <select list>
FROM <source>
WHERE <filter>
...
```

### INSERT EXEC
Insert values from the result set returned by dynamic sql or a stored procedure
```sql
INSERT INTO <table> (<columns>)
EXEC <proc> <parameters>
```

### SELECT INTO
Creates a table based on the source definition and inserts values from a query

```sql
SELECT <select list>
INTO <target>
FROM <source>
WHERE <filter>
...
```

You don't have much control over the definition of the target table.  
- If a source column has an identity property, then the target column will as well.  You can apply manipuation(e.g. `col + 0` 
- Use CAST or CONVERT to convert data types
- If any manipulation is applied to a column, the target column will be marked as NULL
- Use ISNULL to make a target column NON NULL 
- SELECT INTO does not copy any constraints

## Updating Data
### Simple update
```sql
UPDATE <target table>
    SET <col 1> = <exp 1>,
        ...,
        <col n> = <exp n>
WHERE <predicate>;
```

With a variable:
```sql
DECLARE @newdiscount AS NUMERIC(4, 3) = NULL;

UPDATE Sales.MyOrderDetails
  SET @newdiscount = discount += 0.05
WHERE orderid = 10250
  AND productid = 51;

SELECT @newdiscount;
```

Note that updates happen all at once based on the *original* values of the source table.  

### Update based on join
```sql
UPDATE OD
  SET OD.discount += 0.05
FROM Sales.MyCustomers AS C
  INNER JOIN Sales.MyOrders AS O
    ON C.custid = O.custid
  INNER JOIN Sales.MyOrderDetails AS OD
    ON O.orderid = OD.orderid
WHERE C.country = N'Norway';
```
- Can only update one table at a time
- Non-deterministic updates are possible when multiple source rows match one target row.  In this case, SQL server arbitrarily chooses one of the source rows.  It is best to rewrite the update to prevent this.  Example:
```sql
UPDATE C
  SET C.postalcode = O.shippostalcode
FROM Sales.MyCustomers AS C
  INNER JOIN Sales.MyOrders AS O
    ON C.custid = O.custid;
```
Each customer may have many orders, so there is no guarantee which shippostalcode gets applied here

## Deleting Data
### DELETE statement
```sql
DELETE FROM <table>
WHERE <predicate>
```
Can be slow when deleting large volumes of data.  In this case, you can split the delete into chunks using a loop, e.g.
```sql
WHILE 1 = 1
BEGIN
  DELETE TOP (1000) FROM Sales.MyOrderDetails
  WHERE productid = 12;

  IF @@rowcount < 1000 BREAK;
END
```

### TRUNCATE TABLE
Optimized statement that deletes all rows from the target table.  
- Resets IDENTITY properties
- Not allowed if there are FKs pointing to the table, even if there are no related rows(DELETE is allowed in these cases)
- Not supported if there are any indexed views based on the table

## Merge
Syntax
```sql
MERGE INTO <target> AS TGT
USING <source> AS SRC
    ON <merge predicate>
WHEN MATCHED [AND <predicate>] -- two allowed, one with update one with delete
    THEN <action>
WHEN NOT MATCHED [BY TARGET] [AND <predicate>] -- one allowed
    THEN INSERT...
WHEN NOT MATCHED BY SOURCE [AND <predicate>] -- two allowed, one with update and one with delete
    THEN <action>
```
Example
```sql
DECLARE @Orders AS TABLE
(
  orderid   INT  NOT NULL PRIMARY KEY,
  custid    INT  NOT NULL,
  empid     INT  NOT NULL,
  orderdate DATE NOT NULL
);

INSERT INTO @Orders(orderid, custid, empid, orderdate)
  VALUES (2, 1, 3, '20170212'),
         (3, 2, 2, '20170212'),
         (4, 3, 5, '20170212');

-- update where exists (only if different), insert where not exists,
-- delete when exists in target but not in source
MERGE INTO Sales.MyOrders AS TGT
USING @Orders AS SRC
  ON SRC.orderid = TGT.orderid
WHEN MATCHED AND EXISTS( SELECT SRC.* EXCEPT SELECT TGT.* ) THEN
  UPDATE
    SET TGT.custid    = SRC.custid,
        TGT.empid     = SRC.empid,
        TGT.orderdate = SRC.orderdate
WHEN NOT MATCHED THEN
  INSERT VALUES(SRC.orderid, SRC.custid, SRC.empid, SRC.orderdate)
WHEN NOT MATCHED BY SOURCE THEN
  DELETE;
```

## Output examples
### INSERT
```sql
INSERT INTO Sales.MyOrders(custid, empid, orderdate)
  OUTPUT
    inserted.orderid, inserted.custid, inserted.empid, inserted.orderdate
  SELECT custid, empid, orderdate
  FROM Sales.Orders
  WHERE shipcountry = N'Norway';
```
### DELETE
```sql
DELETE FROM Sales.MyOrders
  OUTPUT deleted.orderid
WHERE empid = 1;
```

### UPDATE
```sql
UPDATE Sales.MyOrders
  SET orderdate = DATEADD(day, 1, orderdate)
  OUTPUT
    inserted.orderid,
    deleted.orderdate AS old_orderdate,
    inserted.orderdate AS neworderdate
WHERE empid = 7;
```

### MERGE
```sql
MERGE INTO Sales.MyOrders AS TGT
USING (VALUES(1, 70, 1, '20151218'), (2, 70, 7, '20160429'), (3, 70, 7, '20160820'),
             (4, 70, 3, '20170114'), (5, 70, 1, '20170226'), (6, 70, 2, '20170410'))
       AS SRC(orderid, custid, empid, orderdate)
  ON SRC.orderid = TGT.orderid
WHEN MATCHED AND EXISTS( SELECT SRC.* EXCEPT SELECT TGT.* ) THEN
  UPDATE SET TGT.custid    = SRC.custid,
             TGT.empid     = SRC.empid,
             TGT.orderdate = SRC.orderdate
WHEN NOT MATCHED THEN
  INSERT VALUES(SRC.orderid, SRC.custid, SRC.empid, SRC.orderdate)
WHEN NOT MATCHED BY SOURCE THEN
  DELETE
OUTPUT
  $action AS the_action,
  COALESCE(inserted.orderid, deleted.orderid) AS orderid;
```

## Altering tables
### Adding a column
```sql
ALTER TABLE <table> ADD <col> <constraint> [WITH VALUES]
```

If table is nonempty, and you add a non-null column, then it must have a default constraint.  If you add a NULL column with a default constraint, then use WITH VALUES to apply the constraint to existing rows

### Dropping a column
```sql
ALTER TABLE <table> DROP COLUMN <col>
```
Will fail if the column
- Is used in an index
- Is used in a default, check, foreign key, unique, or primary key constraint
- is bound to a default object or rule

### Altering a column
```sql
ALTER TABLE <table> ALTER COLUMN <col> WITH (ONLINE = ON | OFF)
```
Will fail if the column
- Is used in a primary key or foreign key constraint
- Is used in a check or unique constraint, unless you're just keeping or increasing the length of a variable-length column
- Is used in a default constraint, unless you're changing the length, precision, or scale of column

If a column is included in a primary key, you cannot alter it from NOT NULL to NULL, otherwise you can

You can alter a NULL column to NOT NULL iff there are no NULLs present in the data.   
